<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Snake Game — Reem Hamraz</title>
  <meta name="description" content="Classic Snake Game implemented with HTML5 Canvas — deployable on Vercel" />
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#10b981;
      --muted:#94a3b8;
      --danger:#ef4444;
      --glass: rgba(255,255,255,0.04);
      --card-radius:14px;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#071021);font-family:Inter,system-ui,Arial,Helvetica,sans-serif;color:#e6eef8}
    .wrap{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:24px}
    .app{display:grid;grid-template-columns:420px 1fr;gap:20px;max-width:1100px;width:100%;align-items:start}
    .card{background:var(--panel);padding:18px;border-radius:var(--card-radius);box-shadow:0 6px 20px rgba(2,6,23,0.6);}
    .left{display:flex;flex-direction:column;gap:12px}
    .title{display:flex;align-items:center;gap:12px}
    .logo{width:48px;height:48px;border-radius:10px;background:linear-gradient(135deg,var(--accent),#06b6d4);display:flex;align-items:center;justify-content:center;font-weight:700;color:#031018}
    h1{font-size:18px;margin:0}
    p.small{margin:0;color:var(--muted);font-size:13px}

    canvas{background:linear-gradient(180deg,#061226 0%, #071829 100%);border-radius:10px;display:block;width:100%;height:auto}

    .controls{display:flex;gap:8px;flex-wrap:wrap}
    button{background:var(--glass);border:1px solid rgba(255,255,255,0.04);color:inherit;padding:8px 10px;border-radius:8px;font-weight:600;cursor:pointer}
    button.primary{background:linear-gradient(90deg,var(--accent),#06b6d4);color:#001018;border:none}
    .muted{color:var(--muted);font-size:13px}

    .stats{display:flex;gap:8px;flex-wrap:wrap}
    .stat{background:rgba(255,255,255,0.03);padding:10px;border-radius:8px;min-width:110px;text-align:center}
    .stat .n{font-weight:700;font-size:18px}
    .footer{font-size:13px;color:var(--muted);margin-top:6px}

    @media(max-width:880px){
      .app{grid-template-columns:1fr;}
      .left{order:2}
      .card{padding:12px}
    }

    .touch-controls{display:none;position:fixed;left:0;right:0;bottom:18px;margin:auto;max-width:420px;gap:8px;justify-content:center}
    .touch-btn{background:rgba(255,255,255,0.03);padding:12px;border-radius:12px;min-width:56px;text-align:center;cursor:pointer}
    @media (hover:none) and (pointer:coarse){.touch-controls{display:flex}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="app">
      <div class="card left">
        <div class="title">
          <div class="logo">S</div>
          <div>
            <h1>Snake Game</h1>
            <p class="small">Classic Snake — HTML5 Canvas • Keyboard + Touch • High score saved</p>
          </div>
        </div>

        <canvas id="gameCanvas" width="400" height="400"></canvas>

        <div style="display:flex;justify-content:space-between;align-items:center;margin-top:10px">
          <div class="controls">
            <button id="startBtn" class="primary">Start</button>
            <button id="pauseBtn">Pause</button>
            <button id="resetBtn">Reset</button>
          </div>
          <div class="stats">
            <div class="stat"><div class="n" id="score">0</div><div class="muted">Score</div></div>
            <div class="stat"><div class="n" id="highScore">0</div><div class="muted">High Score</div></div>
          </div>
        </div>

        <div class="footer">Use arrow keys / WASD to play. Swipe on mobile.</div>

        <div style="margin-top:12px;display:flex;gap:8px;align-items:center;flex-wrap:wrap">
          <label class="muted">Speed</label>
          <input id="speedRange" type="range" min="4" max="20" value="10" />
          <label class="muted">Grid</label>
          <select id="gridSize">
            <option value="16">Small</option>
            <option value="20" selected>Medium</option>
            <option value="28">Large</option>
          </select>
        </div>

        <p class="muted" style="margin-top:10px">Deploy: Save as <code>index.html</code> → push to GitHub → import repo on Vercel (static site).</p>
      </div>

      <div class="card">
        <h2 style="margin-top:0">How to play</h2>
        <ol style="color:var(--muted);padding-left:18px">
          <li>Press <strong>Start</strong> to begin. Use arrow keys / WASD or swipe on mobile to steer.</li>
          <li>Eat food to grow. Avoid colliding with walls or the snake's body.</li>
          <li>Adjust speed & grid to change difficulty. High score stored in browser localStorage.</li>
        </ol>

        <h3 style="margin-bottom:6px">Features</h3>
        <ul style="color:var(--muted);padding-left:18px">
          <li>Smooth animation using <code>requestAnimationFrame</code>.</li>
          <li>Collision detection, random food spawn, responsive canvas.</li>
          <li>Mobile-friendly: touch swipe support, on-screen controls on mobile.</li>
        </ul>

        <h3 style="margin-bottom:6px">Want customization?</h3>
        <p class="muted">I can tweak visuals, add levels, leaderboards, or export a GitHub Pages + Vercel deployment CI for you.</p>
      </div>
    </div>

    <div class="touch-controls">
      <div class="touch-btn" id="touchLeft">◀</div>
      <div class="touch-btn" id="touchUp">▲</div>
      <div class="touch-btn" id="touchDown">▼</div>
      <div class="touch-btn" id="touchRight">▶</div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const resetBtn = document.getElementById('resetBtn');
    const scoreEl = document.getElementById('score');
    const highEl = document.getElementById('highScore');
    const speedRange = document.getElementById('speedRange');
    const gridSizeSelect = document.getElementById('gridSize');

    let GRID_SIZE = 20;
    let CELL_SIZE = 20;
    let SPEED = 10;
    
    let snake = [];
    let direction = { x: 0, y: 0 };
    let food = { x: 0, y: 0 };
    let score = 0;
    let highScore = parseInt(localStorage.getItem('snake_high') || '0', 10);
    let isRunning = false;
    let gameLoop = null;

    highEl.textContent = highScore;

    function init() {
      GRID_SIZE = parseInt(gridSizeSelect.value, 10);
      SPEED = parseInt(speedRange.value, 10);
      CELL_SIZE = canvas.width / GRID_SIZE;
      
      const startPos = Math.floor(GRID_SIZE / 2);
      snake = [{ x: startPos, y: startPos }];
      direction = { x: 0, y: 0 };
      score = 0;
      scoreEl.textContent = score;
      isRunning = false;
      
      placeFood();
      draw();
    }

    function placeFood() {
      while (true) {
        food.x = Math.floor(Math.random() * GRID_SIZE);
        food.y = Math.floor(Math.random() * GRID_SIZE);
        
        const onSnake = snake.some(segment => segment.x === food.x && segment.y === food.y);
        if (!onSnake) break;
      }
    }

    function update() {
      if (!isRunning) return;
      
      if (direction.x === 0 && direction.y === 0) return;

      const head = {
        x: snake[0].x + direction.x,
        y: snake[0].y + direction.y
      };

      if (head.x < 0 || head.x >= GRID_SIZE || head.y < 0 || head.y >= GRID_SIZE) {
        endGame();
        return;
      }

      if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
        endGame();
        return;
      }

      snake.unshift(head);

      if (head.x === food.x && head.y === food.y) {
        score += 10;
        scoreEl.textContent = score;
        placeFood();
      } else {
        snake.pop();
      }

      draw();
    }

    function draw() {
      ctx.fillStyle = '#07101a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.globalAlpha = 0.05;
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 1;
      for (let i = 0; i <= GRID_SIZE; i++) {
        ctx.beginPath();
        ctx.moveTo(i * CELL_SIZE, 0);
        ctx.lineTo(i * CELL_SIZE, canvas.height);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.moveTo(0, i * CELL_SIZE);
        ctx.lineTo(canvas.width, i * CELL_SIZE);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;

      // Draw food with gradient and glow
      const foodX = food.x * CELL_SIZE;
      const foodY = food.y * CELL_SIZE;
      
      // Outer glow
      const foodGlow = ctx.createRadialGradient(
        foodX + CELL_SIZE / 2, foodY + CELL_SIZE / 2, 0,
        foodX + CELL_SIZE / 2, foodY + CELL_SIZE / 2, CELL_SIZE * 0.8
      );
      foodGlow.addColorStop(0, 'rgba(239, 68, 68, 0.4)');
      foodGlow.addColorStop(1, 'rgba(239, 68, 68, 0)');
      ctx.fillStyle = foodGlow;
      ctx.fillRect(foodX - CELL_SIZE * 0.3, foodY - CELL_SIZE * 0.3, CELL_SIZE * 1.6, CELL_SIZE * 1.6);
      
      // Food gradient
      const foodGradient = ctx.createRadialGradient(
        foodX + CELL_SIZE / 2, foodY + CELL_SIZE / 2, 0,
        foodX + CELL_SIZE / 2, foodY + CELL_SIZE / 2, CELL_SIZE / 2
      );
      foodGradient.addColorStop(0, '#ff6b6b');
      foodGradient.addColorStop(0.7, '#ef4444');
      foodGradient.addColorStop(1, '#dc2626');
      ctx.fillStyle = foodGradient;
      drawRoundedRect(foodX + 2, foodY + 2, CELL_SIZE - 4, CELL_SIZE - 4, 6);
      
      // Food highlight
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      drawRoundedRect(foodX + 3, foodY + 3, CELL_SIZE * 0.4, CELL_SIZE * 0.25, 3);

      // Draw snake with gradients and depth
      snake.forEach((segment, index) => {
        const x = segment.x * CELL_SIZE;
        const y = segment.y * CELL_SIZE;
        
        if (index === 0) {
          // Head with gradient and glow
          const headGlow = ctx.createRadialGradient(
            x + CELL_SIZE / 2, y + CELL_SIZE / 2, 0,
            x + CELL_SIZE / 2, y + CELL_SIZE / 2, CELL_SIZE * 0.8
          );
          headGlow.addColorStop(0, 'rgba(16, 185, 129, 0.3)');
          headGlow.addColorStop(1, 'rgba(16, 185, 129, 0)');
          ctx.fillStyle = headGlow;
          ctx.fillRect(x - CELL_SIZE * 0.3, y - CELL_SIZE * 0.3, CELL_SIZE * 1.6, CELL_SIZE * 1.6);
          
          const headGradient = ctx.createLinearGradient(x, y, x + CELL_SIZE, y + CELL_SIZE);
          headGradient.addColorStop(0, '#34d399');
          headGradient.addColorStop(0.5, '#10b981');
          headGradient.addColorStop(1, '#059669');
          ctx.fillStyle = headGradient;
          drawRoundedRect(x + 1, y + 1, CELL_SIZE - 2, CELL_SIZE - 2, 6);
          
          // Head highlight
          ctx.fillStyle = 'rgba(255,255,255,0.25)';
          drawRoundedRect(x + 3, y + 3, CELL_SIZE - 6, CELL_SIZE * 0.4, 4);
          
          // Eyes
          const eyeSize = CELL_SIZE * 0.15;
          ctx.fillStyle = '#031018';
          if (direction.x === 1) {
            ctx.fillRect(x + CELL_SIZE * 0.65, y + CELL_SIZE * 0.3, eyeSize, eyeSize);
            ctx.fillRect(x + CELL_SIZE * 0.65, y + CELL_SIZE * 0.55, eyeSize, eyeSize);
          } else if (direction.x === -1) {
            ctx.fillRect(x + CELL_SIZE * 0.2, y + CELL_SIZE * 0.3, eyeSize, eyeSize);
            ctx.fillRect(x + CELL_SIZE * 0.2, y + CELL_SIZE * 0.55, eyeSize, eyeSize);
          } else if (direction.y === -1) {
            ctx.fillRect(x + CELL_SIZE * 0.3, y + CELL_SIZE * 0.2, eyeSize, eyeSize);
            ctx.fillRect(x + CELL_SIZE * 0.55, y + CELL_SIZE * 0.2, eyeSize, eyeSize);
          } else {
            ctx.fillRect(x + CELL_SIZE * 0.3, y + CELL_SIZE * 0.65, eyeSize, eyeSize);
            ctx.fillRect(x + CELL_SIZE * 0.55, y + CELL_SIZE * 0.65, eyeSize, eyeSize);
          }
        } else {
          // Body segments with gradient
          const bodyGradient = ctx.createLinearGradient(x, y, x + CELL_SIZE, y + CELL_SIZE);
          const alpha = 1 - (index / snake.length) * 0.3;
          bodyGradient.addColorStop(0, `rgba(16, 185, 129, ${alpha})`);
          bodyGradient.addColorStop(0.5, `rgba(6, 95, 70, ${alpha})`);
          bodyGradient.addColorStop(1, `rgba(4, 64, 48, ${alpha})`);
          ctx.fillStyle = bodyGradient;
          drawRoundedRect(x + 1, y + 1, CELL_SIZE - 2, CELL_SIZE - 2, 5);
          
          // Body shine
          ctx.fillStyle = `rgba(255,255,255,${0.1 * alpha})`;
          drawRoundedRect(x + 2, y + 2, CELL_SIZE - 4, CELL_SIZE * 0.35, 3);
        }
      });
    }

    function drawRoundedRect(x, y, width, height, radius) {
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + width - radius, y);
      ctx.arcTo(x + width, y, x + width, y + radius, radius);
      ctx.lineTo(x + width, y + height - radius);
      ctx.arcTo(x + width, y + height, x + width - radius, y + height, radius);
      ctx.lineTo(x + radius, y + height);
      ctx.arcTo(x, y + height, x, y + height - radius, radius);
      ctx.lineTo(x, y + radius);
      ctx.arcTo(x, y, x + radius, y, radius);
      ctx.closePath();
      ctx.fill();
    }

    function endGame() {
      isRunning = false;
      clearInterval(gameLoop);
      
      if (score > highScore) {
        highScore = score;
        localStorage.setItem('snake_high', String(highScore));
        highEl.textContent = highScore;
      }
      
      showMessage('Game Over — Press Start to play again');
    }

    function showMessage(msg) {
      const old = document.querySelector('.flash');
      if (old) old.remove();
      
      const el = document.createElement('div');
      el.className = 'flash';
      el.textContent = msg;
      el.style.cssText = 'position:fixed;left:50%;top:18px;transform:translateX(-50%);background:linear-gradient(90deg,#ef4444,#f97316);padding:8px 14px;border-radius:8px;font-weight:700;box-shadow:0 6px 20px rgba(0,0,0,0.6);z-index:1000';
      document.body.appendChild(el);
      setTimeout(() => el.remove(), 2000);
    }

    function changeDirection(newDir) {
      if (direction.x === 0 && direction.y === 0) {
        direction = newDir;
        return;
      }
      
      if (newDir.x === -direction.x && newDir.y === -direction.y) {
        return;
      }
      
      direction = newDir;
    }

    startBtn.addEventListener('click', () => {
      if (!isRunning) {
        isRunning = true;
        if (direction.x === 0 && direction.y === 0) {
          direction = { x: 1, y: 0 };
        }
        if (gameLoop) clearInterval(gameLoop);
        gameLoop = setInterval(update, 1000 / SPEED);
      }
    });

    pauseBtn.addEventListener('click', () => {
      isRunning = !isRunning;
      if (isRunning) {
        gameLoop = setInterval(update, 1000 / SPEED);
      } else {
        clearInterval(gameLoop);
      }
    });

    resetBtn.addEventListener('click', () => {
      clearInterval(gameLoop);
      init();
    });

    speedRange.addEventListener('input', () => {
      SPEED = parseInt(speedRange.value, 10);
      if (isRunning) {
        clearInterval(gameLoop);
        gameLoop = setInterval(update, 1000 / SPEED);
      }
    });

    gridSizeSelect.addEventListener('change', () => {
      clearInterval(gameLoop);
      init();
    });

    window.addEventListener('keydown', (e) => {
      switch(e.key) {
        case 'ArrowUp':
        case 'w':
        case 'W':
          changeDirection({ x: 0, y: -1 });
          e.preventDefault();
          break;
        case 'ArrowDown':
        case 's':
        case 'S':
          changeDirection({ x: 0, y: 1 });
          e.preventDefault();
          break;
        case 'ArrowLeft':
        case 'a':
        case 'A':
          changeDirection({ x: -1, y: 0 });
          e.preventDefault();
          break;
        case 'ArrowRight':
        case 'd':
        case 'D':
          changeDirection({ x: 1, y: 0 });
          e.preventDefault();
          break;
        case ' ':
          pauseBtn.click();
          e.preventDefault();
          break;
      }
    });

    let touchStartX = 0;
    let touchStartY = 0;

    canvas.addEventListener('touchstart', (e) => {
      const touch = e.touches[0];
      touchStartX = touch.clientX;
      touchStartY = touch.clientY;
    });

    canvas.addEventListener('touchend', (e) => {
      const touch = e.changedTouches[0];
      const dx = touch.clientX - touchStartX;
      const dy = touch.clientY - touchStartY;
      const threshold = 30;

      if (Math.abs(dx) > Math.abs(dy)) {
        if (Math.abs(dx) > threshold) {
          changeDirection(dx > 0 ? { x: 1, y: 0 } : { x: -1, y: 0 });
        }
      } else {
        if (Math.abs(dy) > threshold) {
          changeDirection(dy > 0 ? { x: 0, y: 1 } : { x: 0, y: -1 });
        }
      }
    });

    document.getElementById('touchUp').addEventListener('click', () => changeDirection({ x: 0, y: -1 }));
    document.getElementById('touchDown').addEventListener('click', () => changeDirection({ x: 0, y: 1 }));
    document.getElementById('touchLeft').addEventListener('click', () => changeDirection({ x: -1, y: 0 }));
    document.getElementById('touchRight').addEventListener('click', () => changeDirection({ x: 1, y: 0 }));

    init();
  </script>
</body>
</html>
